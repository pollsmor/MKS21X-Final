import java.util.Random;
import java.util.ArrayList;

public class Floor{
  private Block[][] blocksHere; //Array of Blocks (like patches)
  private int floorNumber;
  private int width;
  private int length;
  private ArrayList<Room> roomsHere; //ArrayList of Rooms
  private int numRooms; //Number of successful Rooms
  private ArrayList<Tunnel> tunnelsHere; //ArrayList of total Tunnels created

  //public Floor(int num, int terminal Width, int terminalLength)
  /** Constructs a Floor based on the terminal width and length and assigns the floor a number
    *@param num an int which will become the floorNumber
    *@param terminalWidth an int which will become the floor's width (used for creating blocksHere)
    *@param terminalLength an int which will become the floor's length (used for creating blocksHere)
  */
  public Floor(int num, int terminalWidth, int terminalLength){
    floorNumber = num;
    width = terminalWidth;
    length = terminalLength;
    blocksHere = new Block[length][width];
    for (int y = 0; y < length; y++) {
      for (int x = 0; x < width; x++) {
        blocksHere[y][x] = new Block(x, y, "Wall");
      }
    }
  }

  public Block getBlock(int row, int col) {
    return blocksHere[row][col];
  }
  public void setBlock(int row, int col, Block b){
    blocksHere[row][col] = new Block(row, col, "Tunnel");
  }

  //public int getFloorNumber()
  /**Returns the number of floors the Player has successfully passed
    *@return floorNumber: an int which represents the number of Floors played in the current Game
  */
  public int getFloorNumber(){
    return floorNumber;
  }
  //public int getWidth()
  /**Returns the width of the Floor
    *@return width: an int which represents the width of the current Floor
  */
  public int getWidth(){
    return width;
  }
  //public int getLength()
  /**Returns the length of the Floor
    *@return length: an int which represents the length of the current Floor
  */
  public int getLength(){
    return length;
  }

  //public void createRooms(int seed)
  /**Spawns rooms on the Floor given a seed
    *@param seed is an int given to randomly generate Rooms
  */
  public void createRooms(int seed){
    for (int y = 0; y < blocksHere.length; y++){
      for (int x = 0; x < blocksHere[y].length;x++){
        //Reset all Blocks' canMoves
        blocksHere[y][x].setCanMove('u',false);
        blocksHere[y][x].setCanMove('d',false);
        blocksHere[y][x].setCanMove('l',false);
        blocksHere[y][x].setCanMove('r',false);
      }
    }
    Random rnd = new Random(seed); //Takes seed generated by Game class
    //First decide number of Rooms to create
    int rooms = rnd.nextInt(3) + (width+length)/10;
    roomsHere = new ArrayList<Room>(rooms);
    tunnelsHere = new ArrayList<Tunnel>(rooms);
    //System.out.println("Rooms: "+rooms);
    int attempts = 500; //In case it's impossible to create all the rooms, have a set number of failed attempts possible
    //Using random, generate the xcors and ycors of top right Blocks and bottom left Blocks of the Rooms
    //Minimum width of room: 5 | Max: 12
    //Minimum length of room: 5 | Max: 12
    int startXcor, startYcor, endXcor, endYcor;
    int successfulRooms = 0; //Keep track of how many Rooms were successfully made
    boolean wasOverlap; //Keep track of whether or Room to be created overlaps with any other Room
    Room r, chosenRoom;
    while (successfulRooms < rooms && attempts > 0){
      //Getting possible coordinates of a new Room
      startXcor = Math.abs(rnd.nextInt(width - 13)) + 1;
      endXcor = startXcor + rnd.nextInt(7) + 5;
      startYcor = Math.abs(rnd.nextInt(length - 13)) + 1;
      endYcor = startYcor + rnd.nextInt(7) + 5;
      wasOverlap = false; //boolean to check if the Rooms are tooClose to each other
      //Make sure that rooms don't overlap with each other
      for (int i = 0; i < successfulRooms; i++){
        if (roomsHere.get(i).tooClose(startXcor, startYcor, endXcor, endYcor)){
          wasOverlap = true;
          i = roomsHere.size(); //Stop loop once it has been discovered that a Room will overlap the new one
          attempts--; //Reduce attempts by 1
        }
      }
      if (!wasOverlap){ //If there were no overlapping Rooms, create the Room
        r = createRoom(startXcor, startYcor, endXcor, endYcor);
        if (successfulRooms != 0){
        chosenRoom = roomsHere.get(rnd.nextInt(successfulRooms));
        r.connectRooms(chosenRoom, seed, this);
      }
      roomsHere.add(r);
      successfulRooms++;
        //Connect to a room
        //Create a tunnel
        //Allow tunnels to pass through each other
      }
    }
    numRooms = successfulRooms;
    spawnObjective(rnd.nextInt(10000));
  }

  //public Room createRoom(int startXcor, int startYcor, int endXcor, int endYcor)
  /**Creates a single room given the coordinates of the start and end Blocks
    *@param startXcor is the int representing the x-coordinate of the starting Block
    *@param startYcor is the int representing the y-coordinate of the starting Block
    *@param endXcor is the int representing the x-coordinate of the ending Block
    *@param endYcor is the int representing the y-coordinate of the ending Block
    *@return the new successfully created Room
  */
  public Room createRoom(int startXcor, int startYcor, int endXcor, int endYcor){
    Room a = new Room(startXcor, startYcor, endXcor, endYcor);
    //Must also update blocksHere
    for (int y = startYcor; y < endYcor + 1; y++){
      for (int x = startXcor; x < endXcor + 1; x++){
        blocksHere[y][x] = new Block(x,y,"Room");
      }
    }
    return a;
  }

  public String toString(){
    String output = " |";
    int n = 0;
    for (int y = 0; y < width; y++){
      output += n%10;
      n++;
    }
    output += "|\n";
    n = 0;
    for (int y = 0; y < length; y++){
      output+=n%10;
      output+="|";
      n++;
      for (int x = 0; x < width; x++){
        output+= blocksHere[y][x].getData();
      }
      output+="|\n";
    }
    output +=" |";
    for (int y = 0; y < width; y++){
      output += "-";
    }

    return output+"|";
  }

  public Block[][] getBlocksHere(){
    return blocksHere;
  }

  public ArrayList<Room> getRoomsHere(){
    return roomsHere;
  }

  public static String toStringBlocks(Block[][] b){
    String output = "";
    for (int i = 0; i < b.length; i++){
      for (int j = 0; j < b[i].length; j++){
        output += b[i][j].getData();
        if (i!=b[i].length - 1){
          output += ", ";
        }
      }
      if (i!=b.length - 1){
        output += "\n";
      }
    }
    return output;
  }

  //toString makes a coordinate system that is offset from the one the blocksHere array uses.
  public String toStringClean() {
    String cyan = "\u001B[36m";
    String bgWhite = "\u001b[47m";
    String resetColor = "\u001b[0m";
    String blink = "\u001B[5m";
    String output = "";

    for (int i = 0; i < length; ++i) {
      for (int j = 0; j < width; ++j) {
        if (j == width - 1)
          output += "|";

        else {
          if (blocksHere[i][j].getType().equals("Room"))
            output += blocksHere[i][j].getData();

          else if (blocksHere[i][j].getType().equals("Tunnel"))
            output += blocksHere[i][j].getData();

          else if (blocksHere[i][j].getType().equals("Objective"))
            output += (cyan + blink + blocksHere[i][j].getData() + resetColor);

          else
            output += (bgWhite + blocksHere[i][j].getData() + resetColor);
          }
      }

      output += '\n';
    }

    for (int x = 0; x < width; ++x)
      output += '-';

    return output;
  }

  //public void addTunnel(Tunnel t)
  /**Adds a Tunnel to blocksHere
    *@param t is a Tunnel which is to be added to the Floor
    *@param direction is an int representing the direction the Tunnel is: 0 for left right, 1 for up down
  */
  public void addTunnel(Tunnel t, int direction){
    Block b;
    boolean up, down, left, right;
    //System.out.println("Add Tunnel in progress");
    for(int i = 0; i < t.getBlocksHere().length; i++){ //Horizontal
      for(int j = 0; j < t.getBlocksHere()[i].length;j++){
        b = t.getBlocksHere()[i][j];

        if (blocksHere[b.getY()][b.getX()].getType() != "Room"){ //Don't make it a Tunnel Block if it was a Room
          if (blocksHere[b.getY()][b.getX()].getType() == "Tunnel" && blocksHere[b.getY()][b.getX()].getDirection() != direction){
            //Save the old canMoves
            up = blocksHere[b.getY()][b.getX()].canMove('u');
            down = blocksHere[b.getY()][b.getX()].canMove('d');
            left = blocksHere[b.getY()][b.getX()].canMove('l');
            right = blocksHere[b.getY()][b.getX()].canMove('r');

            //Making the new Block
            blocksHere[b.getY()][b.getX()] = new Block(b.getX(), b.getY(), 2);

            //Put the canMoves back
            blocksHere[b.getY()][b.getX()].setCanMove('u', up);
            blocksHere[b.getY()][b.getX()].setCanMove('d', down);
            blocksHere[b.getY()][b.getX()].setCanMove('l', left);
            blocksHere[b.getY()][b.getX()].setCanMove('r', right);
          }
          else{ //If they don't intersect just make a regular new Tunnel Block
            blocksHere[b.getY()][b.getX()] = new Block(b.getX(), b.getY(), direction);
          }
          if (direction == 0){ //Horizontal
            if (j != 0){ //if not the left most, pokemon can move left
              blocksHere[b.getY()][b.getX()].setCanMove('l', true);
            }
            if (j != t.getBlocksHere()[i].length - 1){ //if not right most, pokemon can move right
              blocksHere[b.getY()][b.getX()].setCanMove('r', true);
            }
          }
          else{ //Vertical
            if (i != 0){ //if not the top most, pokemon can move up
              blocksHere[b.getY()][b.getX()].setCanMove('u', true);
            }
            if (i != t.getBlocksHere().length - 1){ //if not bottom most, pokemon can move down
              blocksHere[b.getY()][b.getX()].setCanMove('d', true);
            }
          }
        }
      }
    }
    tunnelsHere.add(t);
  }

  public void spawnObjective(int seed){
    for (int y = 0; y < blocksHere.length; y++){
      for (int x = 0; x < blocksHere[y].length;x++){
        blocksHere[y][x].setObjectiveHere(false);
      }
    }
    Random rnd = new Random(seed);
    int n = rnd.nextInt(roomsHere.size()); //Selecting a random Room to spawn the objective Block
    Room spawnRoom = roomsHere.get(n);
    int r = rnd.nextInt(spawnRoom.getBlocksHere().length); //Selecting a random row of Blocks in the Room to spawn the objective Block
    Block[] spawnRow = spawnRoom.getBlocksHere()[r];
    int c = rnd.nextInt(spawnRow.length); //Selecting a random Block in the spawnRow in the Room to spawn the objective Block
    Block spawnBlock = spawnRow[c];
    spawnBlock.spawnObjective();
    blocksHere[spawnBlock.getY()][spawnBlock.getX()] = spawnBlock;
  }

  public void spawnPlayer(int seed, Player player){
    for (int y = 0; y < blocksHere.length; y++){
      for (int x = 0; x < blocksHere[y].length;x++){
        blocksHere[y][x].setPokemonHere(null);
      }
    }
    Random rnd = new Random(seed);
    int n = rnd.nextInt(roomsHere.size()); //Selecting a random Room to spawn the objective Block
    Room spawnRoom = roomsHere.get(n);
    int r = rnd.nextInt(spawnRoom.getBlocksHere().length); //Selecting a random row of Blocks in the Room to spawn the objective Block
    Block[] spawnRow = spawnRoom.getBlocksHere()[r];
    int c = rnd.nextInt(spawnRow.length); //Selecting a random Block in the spawnRow in the Room to spawn the objective Block
    Block spawnBlock = spawnRow[c];
    spawnBlock.spawnPlayerHere(player);
    blocksHere[spawnBlock.getY()][spawnBlock.getX()] = spawnBlock;
  }
}
